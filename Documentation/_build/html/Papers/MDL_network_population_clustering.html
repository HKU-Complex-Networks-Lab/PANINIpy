<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Clustering Network Populations &mdash; Scholar Code Collective  documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../_static/custom.css?v=1fa8549b" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js?v=5d32c60e"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../_static/documentation_options.js?v=5929fcd5"></script>
        <script src="../_static/doctools.js?v=9a2dae69"></script>
        <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Regionalization with Distributional Data" href="MDL_regionalization.html" />
    <link rel="prev" title="Binning Temporal Hypergraphs" href="hypergraph_binning.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Scholar Code Collective
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Methods:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="hypergraph_binning.html">Binning Temporal Hypergraphs</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Clustering Network Populations</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#tutorial">Tutorial</a></li>
<li class="toctree-l2"><a class="reference internal" href="#mdl-population-clustering">MDL Population Clustering</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#functions">Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#demo">Demo</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#example-code">Example Code</a></li>
<li class="toctree-l3"><a class="reference internal" href="#example-output">Example Output</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#paper-source">Paper source</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="MDL_regionalization.html">Regionalization with Distributional Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="Network_hubs.html">Identifying Network Hubs</a></li>
<li class="toctree-l1"><a class="reference internal" href="urban_boundary_delineation.html">Regionalization with Community Detection</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Scholar Code Collective</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Clustering Network Populations</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/Papers/MDL_network_population_clustering.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="clustering-network-populations">
<h1>Clustering Network Populations<a class="headerlink" href="#clustering-network-populations" title="Link to this heading"></a></h1>
<section id="tutorial">
<h2>Tutorial<a class="headerlink" href="#tutorial" title="Link to this heading"></a></h2>
<p>Code to perform clustering network populations derived in ‘Compressing network populations with modal networks reveals structural diversity’. Inputs an event dataset of the form [(edgesets, N, K0, n_fails, bipartite, directed, max_runs)], where:</p>
<ul class="simple">
<li><p><strong>edgesets:</strong> List of sets. The s-th set contains all the edges (i, j) in the s-th network in the sample (do not include the other direction (j, i) if the network is undirected). The order of edgesets within the dataset only matters for contiguous clustering, where we want the edgesets to be in the order of the samples in time.</p></li>
<li><p><strong>N:</strong> Number of nodes in each network.</p></li>
<li><p><strong>K0:</strong> Initial number of clusters (for discontiguous clustering, usually K0 = 1 works well; for contiguous clustering, it does not matter).</p></li>
<li><p><strong>n_fails:</strong> Number of failed reassign/merge/split/merge-split moves before terminating the algorithm.</p></li>
<li><p><strong>bipartite:</strong> ‘None’ for unipartite network populations, array [(# of nodes of type 1, # of nodes of type 2)] otherwise.</p></li>
<li><p><strong>directed:</strong> Set to True when sets of edges input are directed.</p></li>
<li><p><strong>max_runs:</strong> Maximum number of allowed moves, independent of the number of failed moves.</p></li>
</ul>
<p>Outputs a clustering result of the form [(C, A, L)], where:</p>
<ul class="simple">
<li><p><strong>C:</strong> Dictionary with items (cluster label):(set of indices corresponding to networks in the cluster).</p></li>
<li><p><strong>A:</strong> Dictionary with items (cluster label):(set of edges corresponding to the mode of the cluster).</p></li>
<li><p><strong>L:</strong> Inverse compression ratio, which is the description length after clustering divided by the description length of naive transmission.</p></li>
</ul>
<p>using the following clustering objective:</p>
<div class="math" id="equation1">
<p><img src="../_images/math/f1cdd45ce0702123f18e46b80361e37a2c6513e6.png" alt="\[
\mathcal{L}_k\left(\mathcal{A}^{(k)}, C_k\right) = \mathcal{L}\left(\mathcal{A}^{(k)}\right) + S \log\left(\frac{S}{S_k}\right) + \ell_k \tag{1}
\]"/></p>
</div><div class="math" id="equation2">
<p><img src="../_images/math/efd8b5a918f4086226a5f118ba10ccb060752a75.png" alt="\[
\mathcal{L}(\mathcal{D}) = \sum_{k=1}^{K} \mathcal{L}_k\left(\mathcal{A}^{(k)}, C_k\right). \tag{2}
\]"/></p>
</div><p>This method optimizes the Minimum Description Length (MDL) objective for clustering network populations.</p>
<p>Equation <code class="xref eq docutils literal notranslate"><span class="pre">(2)</span></code> gives the total description length of the data <img class="math" src="../_images/math/04e020245e4cf50b3ca4838c0a38291969ad8966.png" alt="\mathcal{D}" style="vertical-align: 0px"/> under our multi-part transmission scheme. By minimizing this objective function we identify the best configurations of modes <img class="math" src="../_images/math/815195624116638e92c59685bd44f81ea86a112f.png" alt="\mathcal{A}" style="vertical-align: -1px"/> and clusters <img class="math" src="../_images/math/ea54a95e10ff190b2dab5d985e1d2687b87e942c.png" alt="\mathcal{C}" style="vertical-align: 0px"/>. A good configuration <img class="math" src="../_images/math/2fe94f8b96e26d3b95a6b6976b392c6d0ce827b4.png" alt="\{\mathcal{A}, \mathcal{C}\}" style="vertical-align: -5px"/> will allow us to transmit a large portion of the information in <img class="math" src="../_images/math/04e020245e4cf50b3ca4838c0a38291969ad8966.png" alt="\mathcal{D}" style="vertical-align: 0px"/> through the modes alone. If we use too many modes, the description length will increase as these are costly to communicate in full. And if we use too few, the description length will also increase because we will have to send lengthy messages describing how mismatched networks and modes differ. Hence, through the principle of parsimony, Eq. <code class="xref eq docutils literal notranslate"><span class="pre">(2)</span></code> favors descriptions with the number of clusters <img class="math" src="../_images/math/88585571da689d8413e899ee1f1e349e1172b9c8.png" alt="K" style="vertical-align: 0px"/> as small as possible but not smaller.</p>
<p><strong>Inputs:</strong></p>
<ul class="simple">
<li><p><strong>edgesets:</strong> list of sets. The s-th set contains all the edges (i, j) in the s-th network in the sample (do not include the other direction (j, i) if the network is undirected). The order of edgesets within D only matters for contiguous clustering, where we want the edgesets to be in order of the samples in time.</p></li>
<li><p><strong>N:</strong> number of nodes in each network</p></li>
<li><p><strong>K0:</strong> initial number of clusters (for discontiguous clustering, usually K0 = 1 works well; for contiguous clustering it does not matter)</p></li>
<li><p><strong>n_fails:</strong> number of failed reassign/merge/split/merge-split moves before terminating the algorithm</p></li>
<li><p><strong>bipartite:</strong> ‘None’ for unipartite network populations, array [# of nodes of type 1, # of nodes of type 2] otherwise</p></li>
<li><p><strong>directed:</strong> Set to True when sets of edges input are directed</p></li>
<li><p><strong>max_runs:</strong> Maximum number of allowed moves, independent of number of failed moves</p></li>
</ul>
<p><strong>Outputs of ‘run_sims’ (unconstrained description length optimization) and ‘dynamic_contiguous’ (restriction to contiguous clusters):</strong></p>
<ul class="simple">
<li><p><strong>C:</strong> dictionary with items (cluster label):(set of indices corresponding to networks in cluster)</p></li>
<li><p><strong>A:</strong> dictionary with items (cluster label):(set of edges corresponding to mode of cluster)</p></li>
<li><p><strong>L:</strong> inverse compression ratio (description length after clustering)/(description length of naive transmission)</p></li>
</ul>
<p><strong>For discontiguous clustering, use:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">MDLobj</span> <span class="o">=</span> <span class="n">MDL_populations</span><span class="p">(</span><span class="n">edgesets</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">n_fails</span><span class="p">,</span> <span class="n">bipartite</span><span class="p">,</span> <span class="n">directed</span><span class="p">,</span> <span class="n">max_runs</span><span class="p">)</span>
<span class="n">MDLobj</span><span class="o">.</span><span class="n">initialize_clusters</span><span class="p">()</span>
<span class="n">C</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="n">MDLobj</span><span class="o">.</span><span class="n">run_sims</span><span class="p">()</span>
</pre></div>
</div>
<p><strong>For contiguous clustering, use:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">MDLobj</span> <span class="o">=</span> <span class="n">MDL_populations</span><span class="p">(</span><span class="n">edgesets</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">K0</span><span class="o">=</span><span class="p">(</span><span class="n">anything</span><span class="p">),</span> <span class="n">n_fails</span><span class="o">=</span><span class="p">(</span><span class="n">anything</span><span class="p">),</span> <span class="n">bipartite</span><span class="p">,</span> <span class="n">directed</span><span class="p">)</span>
<span class="n">C</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="n">MDLobj</span><span class="o">.</span><span class="n">dynamic_contiguous</span><span class="p">()</span>
</pre></div>
</div>
<p>If you use this algorithm, please cite:</p>
<ol class="upperalpha simple">
<li><p>Kirkley, A. Rojas, M. Rosvall, and J-G. Young, Compressing network populations with modal networks reveals structural diversity. Communications Physics 6, 148 (2023).</p></li>
</ol>
</section>
<section id="mdl-population-clustering">
<h2>MDL Population Clustering<a class="headerlink" href="#mdl-population-clustering" title="Link to this heading"></a></h2>
<p>This module contains the code for the MDL (Minimum Description Length) population clustering algorithm.</p>
<section id="functions">
<h3>Functions<a class="headerlink" href="#functions" title="Link to this heading"></a></h3>
<p>All of the following functions are provided in this module and have the same general usage as described below.</p>
<table class="docutils align-default" id="id8">
<caption><span class="caption-text">Functions</span><a class="headerlink" href="#id8" title="Link to this table"></a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Function</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="#generate_synthetic">generate_synthetic(S, N, modes, alphas, betas, pis)</a></p></td>
<td><p>Generate synthetic networks from the heterogeneous population model.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="#ind2ij">generate_synthetic.ind2ij(ind, N)</a></p></td>
<td><p>Convert index to edge indices.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="#remap_keys">remap_keys(Dict)</a></p></td>
<td><p>Remap dict keys to first K integers.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="#MDL_populations_init">MDL_populations.__init__(edgesets, N, K0=1, n_fails=100, bipartite=None, directed=False, max_runs=np.inf)</a></p></td>
<td><p>Initialize the MDL_populations class.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="#MDL_populations_initialize_clusters">MDL_populations.initialize_clusters()</a></p></td>
<td><p>Initialize K0 random clusters and find their modes as well as the total description length of this configuration.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="#MDL_populations_random_key">MDL_populations.random_key()</a></p></td>
<td><p>Generate random key for new cluster.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="#MDL_populations_logchoose">MDL_populations.logchoose(N, K)</a></p></td>
<td><p>Compute the logarithm of the binomial coefficient.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="#MDL_populations_logmult">MDL_populations.logmult(Ns)</a></p></td>
<td><p>Compute the logarithm of the multinomial coefficient.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="#MDL_populations_generate_Ek">MDL_populations.generate_Ek(cluster)</a></p></td>
<td><p>Tally edge counts for networks in the cluster.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="#MDL_populations_update_mode">MDL_populations.update_mode(Ek, Sk)</a></p></td>
<td><p>Generate mode from cluster edge counts by greedily removing least common edges in the cluster.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="#MDL_populations_Lk">MDL_populations.Lk(Ak, Ek, Sk)</a></p></td>
<td><p>Compute cluster description length as a function of mode, edge counts, and size of the cluster.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="#MDL_populations_move1">MDL_populations.move1(k=None)</a></p></td>
<td><p>Reassign randomly chosen network to the best cluster.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="#MDL_populations_move2">MDL_populations.move2()</a></p></td>
<td><p>Merge two randomly chosen clusters.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="#MDL_populations_move3">MDL_populations.move3()</a></p></td>
<td><p>Split randomly chosen cluster in two and perform K-means type algorithm to get these clusters and modes.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="#MDL_populations_move4">MDL_populations.move4()</a></p></td>
<td><p>Merge two randomly chosen clusters then split them.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="#MDL_populations_run_sims">MDL_populations.run_sims()</a></p></td>
<td><p>Run discontiguous (unconstrained) merge split simulations to identify modes and clusters that minimize the description length.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="#MDL_populations_dynamic_contiguous">MDL_populations.dynamic_contiguous()</a></p></td>
<td><p>Minimize description length while constraining clusters to be contiguous in time.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="#MDL_populations_evaluate_partition">MDL_populations.evaluate_partition(partition, contiguous=False)</a></p></td>
<td><p>Evaluate description length of partition.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="reference">
<h3>Reference<a class="headerlink" href="#reference" title="Link to this heading"></a></h3>
<div id="generate_synthetic" class="function-header">
    <span class="class-name">function</span> <span class="function-name">generate_synthetic(S, N, modes, alphas, betas, pis)</span> <a href="#generate_synthetic" class="source-link">[source]</a>
</div><p><strong>Description</strong>:
Generate synthetic networks from the heterogeneous population model.</p>
<p><strong>Parameters</strong>:</p>
<div class="parameter-block">
    (S, N, modes, alphas, betas, pis)
</div>

<ul class="parameter-list">
    <li><span class="param-name">S</span>: Number of synthetic networks to generate.</li>
    <li><span class="param-name">N</span>: Number of nodes in each network.</li>
    <li><span class="param-name">modes</span>: List of modes for the population model.</li>
    <li><span class="param-name">alphas</span>: List of probabilities for true positive edges in each mode.</li>
    <li><span class="param-name">betas</span>: List of probabilities for false positive edges in each mode.</li>
    <li><span class="param-name">pis</span>: List of probabilities for each mode.</li>
</ul><dl class="simple">
<dt><strong>Returns</strong>:</dt><dd><ul class="simple">
<li><p><strong>nets</strong>: List of generated networks.</p></li>
<li><p><strong>cluster_labels</strong>: List of cluster labels for the generated networks.</p></li>
</ul>
</dd>
</dl>
<div id="ind2ij" class="function-header">
    <span class="class-name">function</span> <span class="function-name">generate_synthetic.ind2ij(ind, N)</span> <a href="#ind2ij" class="source-link">[source]</a>
</div><p><strong>Description</strong>:
Convert index to edge indices.</p>
<p><strong>Parameters</strong>:</p>
<div class="parameter-block">
    (ind, N)
</div>

<ul class="parameter-list">
    <li><span class="param-name">ind</span>: Index of the edge.</li>
    <li><span class="param-name">N</span>: Number of nodes in the network.</li>
</ul><dl class="simple">
<dt><strong>Returns</strong>:</dt><dd><ul class="simple">
<li><p><strong>tuple</strong>: Edge indices (i, j).</p></li>
</ul>
</dd>
</dl>
<div id="remap_keys" class="function-header">
    <span class="class-name">function</span> <span class="function-name">remap_keys(Dict)</span> <a href="#remap_keys" class="source-link">[source]</a>
</div><p><strong>Description</strong>:
Remap dict keys to first K integers.</p>
<p><strong>Parameters</strong>:</p>
<div class="parameter-block">
    (Dict)
</div>

<ul class="parameter-list">
    <li><span class="param-name">Dict</span>: Dictionary to remap.</li>
</ul><dl class="simple">
<dt><strong>Returns</strong>:</dt><dd><ul class="simple">
<li><p><strong>Dict</strong>: Remapped dictionary.</p></li>
</ul>
</dd>
</dl>
<div id="MDL_populations_init" class="function-header">
    <span class="class-name">class</span> <span class="function-name">MDL_populations.__init__(edgesets, N, K0=1, n_fails=100, bipartite=None, directed=False, max_runs=np.inf)</span> <a href="#MDL_populations_init" class="source-link">[source]</a>
</div><p><strong>Description</strong>:
Initialize the MDL_populations class.</p>
<p><strong>Parameters</strong>:</p>
<div class="parameter-block">
    (edgesets, N, K0=1, n_fails=100, bipartite=None, directed=False, max_runs=np.inf)
</div>

<ul class="parameter-list">
    <li><span class="param-name">edgesets</span>: List of sets. The s-th set contains all the edges (i, j) in the s-th network in the sample (do not include the other direction (j, i) if the network is undirected).</li>
    <li><span class="param-name">N</span>: Number of nodes in each network.</li>
    <li><span class="param-name">K0</span>: Initial number of clusters (for discontiguous clustering, usually K0 = 1 works well; for contiguous clustering, it does not matter).</li>
    <li><span class="param-name">n_fails</span>: Number of failed reassign/merge/split/merge-split moves before terminating the algorithm.</li>
    <li><span class="param-name">bipartite</span>: 'None' for unipartite network populations, array [# of nodes of type 1, # of nodes of type 2] otherwise.</li>
    <li><span class="param-name">directed</span>: Boolean indicating whether edgesets contain directed edges.</li>
    <li><span class="param-name">max_runs</span>: Maximum number of allowed moves, regardless of the number of fails.</li>
</ul><div id="MDL_populations_initialize_clusters" class="function-header">
    <span class="class-name">function</span> <span class="function-name">MDL_populations.initialize_clusters()</span> <a href="#MDL_populations_initialize_clusters" class="source-link">[source]</a>
</div><p><strong>Description</strong>:
Initialize K0 random clusters and find their modes as well as the total description length of this configuration.</p>
<div id="MDL_populations_random_key" class="function-header">
    <span class="class-name">function</span> <span class="function-name">MDL_populations.random_key()</span> <a href="#MDL_populations_random_key" class="source-link">[source]</a>
</div><p><strong>Description</strong>:
Generate random key for new cluster.</p>
<div id="MDL_populations_logchoose" class="function-header">
    <span class="class-name">function</span> <span class="function-name">MDL_populations.logchoose(N, K)</span> <a href="#MDL_populations_logchoose" class="source-link">[source]</a>
</div><p><strong>Description</strong>:
Compute the logarithm of the binomial coefficient.</p>
<p><strong>Parameters</strong>:</p>
<div class="parameter-block">
    (N, K)
</div>

<ul class="parameter-list">
    <li><span class="param-name">N</span>: Total number of items.</li>
    <li><span class="param-name">K</span>: Number of chosen items.</li>
</ul><dl class="simple">
<dt><strong>Returns</strong>:</dt><dd><ul class="simple">
<li><p><strong>float</strong>: Logarithm of the binomial coefficient.</p></li>
</ul>
</dd>
</dl>
<div id="MDL_populations_logmult" class="function-header">
    <span class="class-name">function</span> <span class="function-name">MDL_populations.logmult(Ns)</span> <a href="#MDL_populations_logmult" class="source-link">[source]</a>
</div><p><strong>Description</strong>:
Compute the logarithm of the multinomial coefficient with the denominator Ns[0]!Ns[1]!….</p>
<p><strong>Parameters</strong>:</p>
<div class="parameter-block">
    (Ns)
</div>

<ul class="parameter-list">
    <li><span class="param-name">Ns</span>: List of counts for the multinomial coefficient.</li>
</ul><dl class="simple">
<dt><strong>Returns</strong>:</dt><dd><ul class="simple">
<li><p><strong>float</strong>: Logarithm of the multinomial coefficient.</p></li>
</ul>
</dd>
</dl>
<div id="MDL_populations_generate_Ek" class="function-header">
    <span class="class-name">function</span> <span class="function-name">MDL_populations.generate_Ek(cluster)</span> <a href="#MDL_populations_generate_Ek" class="source-link">[source]</a>
</div><p><strong>Description</strong>:
Tally edge counts for networks in the cluster.</p>
<p><strong>Parameters</strong>:</p>
<div class="parameter-block">
    (cluster)
</div>

<ul class="parameter-list">
    <li><span class="param-name">cluster</span>: Set of network indices in the cluster.</li>
</ul><dl class="simple">
<dt><strong>Returns</strong>:</dt><dd><ul class="simple">
<li><p><strong>Ek</strong>: Dictionary of edge counts for the cluster.</p></li>
</ul>
</dd>
</dl>
<div id="MDL_populations_update_mode" class="function-header">
    <span class="class-name">function</span> <span class="function-name">MDL_populations.update_mode(Ek, Sk)</span> <a href="#MDL_populations_update_mode" class="source-link">[source]</a>
</div><p><strong>Description</strong>:
Generate mode from cluster edge counts by greedily removing least common edges in the cluster.</p>
<p><strong>Parameters</strong>:</p>
<div class="parameter-block">
    (Ek, Sk)
</div>

<ul class="parameter-list">
    <li><span class="param-name">Ek</span>: Dictionary of edge counts for the cluster.</li>
    <li><span class="param-name">Sk</span>: Size of the cluster.</li>
</ul><dl class="simple">
<dt><strong>Returns</strong>:</dt><dd><ul class="simple">
<li><p><strong>Ak</strong>: Set of edges corresponding to the mode of the cluster.</p></li>
</ul>
</dd>
</dl>
<div id="MDL_populations_Lk" class="function-header">
    <span class="class-name">function</span> <span class="function-name">MDL_populations.Lk(Ak, Ek, Sk)</span> <a href="#MDL_populations_Lk" class="source-link">[source]</a>
</div><p><strong>Description</strong>:
Compute cluster description length as a function of mode, edge counts, and size of the cluster.</p>
<p><strong>Parameters</strong>:</p>
<div class="parameter-block">
    (Ak, Ek, Sk)
</div>

<ul class="parameter-list">
    <li><span class="param-name">Ak</span>: Set of edges corresponding to the mode of the cluster.</li>
    <li><span class="param-name">Ek</span>: Dictionary of edge counts for the cluster.</li>
    <li><span class="param-name">Sk</span>: Size of the cluster.</li>
</ul><dl class="simple">
<dt><strong>Returns</strong>:</dt><dd><ul class="simple">
<li><p><strong>float</strong>: Cluster description length.</p></li>
</ul>
</dd>
</dl>
<div id="MDL_populations_move1" class="function-header">
    <span class="class-name">function</span> <span class="function-name">MDL_populations.move1(k=None)</span> <a href="#MDL_populations_move1" class="source-link">[source]</a>
</div><p><strong>Description</strong>:
Reassign randomly chosen network to the best cluster.</p>
<p><strong>Parameters</strong>:</p>
<div class="parameter-block">
    (k=None)
</div>

<ul class="parameter-list">
    <li><span class="param-name">k</span>: Cluster index (optional).</li>
</ul><dl class="simple">
<dt><strong>Returns</strong>:</dt><dd><ul class="simple">
<li><p><strong>bool</strong>: Whether the move was accepted.</p></li>
<li><p><strong>float</strong>: Change in description length.</p></li>
</ul>
</dd>
</dl>
<div id="MDL_populations_move2" class="function-header">
    <span class="class-name">function</span> <span class="function-name">MDL_populations.move2()</span> <a href="#MDL_populations_move2" class="source-link">[source]</a>
</div><p><strong>Description</strong>:
Merge two randomly chosen clusters.</p>
<dl class="simple">
<dt><strong>Returns</strong>:</dt><dd><ul class="simple">
<li><p><strong>bool</strong>: Whether the move was accepted.</p></li>
<li><p><strong>float</strong>: Change in description length.</p></li>
</ul>
</dd>
</dl>
<div id="MDL_populations_move3" class="function-header">
    <span class="class-name">function</span> <span class="function-name">MDL_populations.move3()</span> <a href="#MDL_populations_move3" class="source-link">[source]</a>
</div><p><strong>Description</strong>:
Split randomly chosen cluster in two and perform K-means type algorithm to get these clusters and modes.</p>
<dl class="simple">
<dt><strong>Returns</strong>:</dt><dd><ul class="simple">
<li><p><strong>bool</strong>: Whether the move was accepted.</p></li>
<li><p><strong>float</strong>: Change in description length.</p></li>
</ul>
</dd>
</dl>
<div id="MDL_populations_move4" class="function-header">
    <span class="class-name">function</span> <span class="function-name">MDL_populations.move4()</span> <a href="#MDL_populations_move4" class="source-link">[source]</a>
</div><p><strong>Description</strong>:
Merge two randomly chosen clusters then split them.</p>
<dl class="simple">
<dt><strong>Returns</strong>:</dt><dd><ul class="simple">
<li><p><strong>bool</strong>: Whether the move was accepted.</p></li>
<li><p><strong>float</strong>: Change in description length.</p></li>
</ul>
</dd>
</dl>
<div id="MDL_populations_run_sims" class="function-header">
    <span class="class-name">function</span> <span class="function-name">MDL_populations.run_sims()</span> <a href="#MDL_populations_run_sims" class="source-link">[source]</a>
</div><p><strong>Description</strong>:
Run discontiguous (unconstrained) merge split simulations to identify modes and clusters that minimize the description length.</p>
<dl class="simple">
<dt><strong>Returns</strong>:</dt><dd><ul class="simple">
<li><p><strong>C</strong>: Dictionary with items (cluster label):(set of indices corresponding to networks in the cluster).</p></li>
<li><p><strong>A</strong>: Dictionary with items (cluster label):(set of edges corresponding to the mode of the cluster).</p></li>
<li><p><strong>L</strong>: Inverse compression ratio (description length after clustering)/(description length of naive transmission).</p></li>
</ul>
</dd>
</dl>
<div id="MDL_populations_dynamic_contiguous" class="function-header">
    <span class="class-name">function</span> <span class="function-name">MDL_populations.dynamic_contiguous()</span> <a href="#MDL_populations_dynamic_contiguous" class="source-link">[source]</a>
</div><p><strong>Description</strong>:
Minimize description length while constraining clusters to be contiguous in time.</p>
<dl class="simple">
<dt><strong>Returns</strong>:</dt><dd><ul class="simple">
<li><p><strong>C</strong>: Dictionary with items (cluster label):(set of indices corresponding to networks in the cluster).</p></li>
<li><p><strong>A</strong>: Dictionary with items (cluster label):(set of edges corresponding to the mode of the cluster).</p></li>
<li><p><strong>L</strong>: Inverse compression ratio (description length after clustering)/(description length of naive transmission).</p></li>
</ul>
</dd>
</dl>
<div id="MDL_populations_evaluate_partition" class="function-header">
    <span class="class-name">function</span> <span class="function-name">MDL_populations.evaluate_partition(partition, contiguous=False)</span> <a href="#MDL_populations_evaluate_partition" class="source-link">[source]</a>
</div><p><strong>Description</strong>:
Evaluate description length of partition. Contiguous option removes cluster label entropy term from description length.</p>
<p><strong>Parameters</strong>:</p>
<div class="parameter-block">
    (partition, contiguous=False)
</div>

<ul class="parameter-list">
    <li><span class="param-name">partition</span>: List of cluster labels for each network.</li>
    <li><span class="param-name">contiguous</span>: Boolean indicating whether to remove cluster label entropy term.</li>
</ul><dl class="simple">
<dt><strong>Returns</strong>:</dt><dd><ul class="simple">
<li><p><strong>float</strong>: Description length of the partition.</p></li>
</ul>
</dd>
</dl>
</section>
</section>
<section id="demo">
<h2>Demo<a class="headerlink" href="#demo" title="Link to this heading"></a></h2>
<section id="example-code">
<h3>Example Code<a class="headerlink" href="#example-code" title="Link to this heading"></a></h3>
<p><strong>Step 1: Import necessary libraries</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">ScholarCodeCollective</span> <span class="k">as</span> <span class="nn">SCC</span>
<span class="kn">from</span> <span class="nn">ScholarCodeCollective.MDL_network_population_clustering_main</span> <span class="kn">import</span> <span class="n">generate_synthetic</span><span class="p">,</span> <span class="n">MDL_populations</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">random</span>
</pre></div>
</div>
<p><strong>Step 2: Function to visualize synthetic clusters</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">visualize_synthetic_clusters</span><span class="p">(</span><span class="n">nets</span><span class="p">,</span> <span class="n">cluster_labels</span><span class="p">,</span> <span class="n">node_num</span><span class="p">):</span>
    <span class="n">num_plots</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nets</span><span class="p">)</span>
    <span class="n">cols</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="n">rows</span> <span class="o">=</span> <span class="p">(</span><span class="n">num_plots</span> <span class="o">//</span> <span class="n">cols</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">num_plots</span> <span class="o">%</span> <span class="n">cols</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
    <span class="n">pos_rectangular</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">half_N</span> <span class="o">=</span> <span class="p">(</span><span class="n">node_num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">node_num</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">half_N</span><span class="p">:</span>
            <span class="n">pos_rectangular</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pos_rectangular</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">half_N</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">cluster_label</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">nets</span><span class="p">,</span> <span class="n">cluster_labels</span><span class="p">)):</span>
        <span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">cols</span><span class="p">)</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span> <span class="k">if</span> <span class="n">rows</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">axes</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">node_num</span><span class="p">))</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">net</span><span class="p">)</span>

        <span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos_rectangular</span><span class="p">,</span> <span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">node_size</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="s1">&#39;skyblue&#39;</span><span class="p">,</span> <span class="n">font_weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Network </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s1"> (Mode </span><span class="si">{</span><span class="n">cluster_label</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">rows</span> <span class="o">*</span> <span class="n">cols</span><span class="p">):</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">delaxes</span><span class="p">(</span><span class="n">axes</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[</span><span class="n">j</span><span class="p">])</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;synthetic_network_clusters.png&#39;</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p><strong>Step 3: Generate synthetic data</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">mode_example</span> <span class="o">=</span> <span class="p">[{(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">)},</span>
    <span class="p">{(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)},</span>
    <span class="p">{(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">)}]</span>

<span class="n">node_num</span> <span class="o">=</span> <span class="mi">8</span>
<span class="n">network_num</span> <span class="o">=</span> <span class="mi">2000</span>
<span class="n">nets</span><span class="p">,</span> <span class="n">cluster_labels</span> <span class="o">=</span> <span class="n">generate_synthetic</span><span class="p">(</span>
    <span class="n">S</span><span class="o">=</span><span class="n">network_num</span><span class="p">,</span>
    <span class="n">N</span><span class="o">=</span><span class="n">node_num</span><span class="p">,</span>
    <span class="n">modes</span><span class="o">=</span><span class="n">mode_example</span><span class="p">,</span>
    <span class="n">alphas</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
    <span class="n">betas</span><span class="o">=</span><span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">],</span>
    <span class="n">pis</span><span class="o">=</span><span class="p">[</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.34</span><span class="p">]</span>
<span class="p">)</span>
</pre></div>
</div>
<p><strong>Step 4: Visualize the synthetic networks</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">visualize_synthetic_clusters</span><span class="p">(</span><span class="n">nets</span><span class="p">,</span> <span class="n">cluster_labels</span><span class="p">,</span> <span class="n">node_num</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Step 5: Run the MDL populations algorithm</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">mdl_pop</span> <span class="o">=</span> <span class="n">MDL_populations</span><span class="p">(</span><span class="n">edgesets</span><span class="o">=</span><span class="n">nets</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="n">node_num</span><span class="p">,</span> <span class="n">K0</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_fails</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">max_runs</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
<span class="n">mdl_pop</span><span class="o">.</span><span class="n">initialize_clusters</span><span class="p">()</span>
<span class="n">clusters</span><span class="p">,</span> <span class="n">modes</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="n">mdl_pop</span><span class="o">.</span><span class="n">run_sims</span><span class="p">()</span>
</pre></div>
</div>
<p><strong>Step 6: Function to visualize clustered networks</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">visualize_clusters</span><span class="p">(</span><span class="n">nets</span><span class="p">,</span> <span class="n">clusters</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">network_num</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s1">&#39;MDL_population_clusters.png&#39;</span><span class="p">):</span>
    <span class="n">num_clusters</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">)</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_clusters</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">num_clusters</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="p">[</span><span class="n">ax</span><span class="p">]</span>

    <span class="n">pos_rectangular</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">half_N</span> <span class="o">=</span> <span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">half_N</span><span class="p">:</span>
            <span class="n">pos_rectangular</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pos_rectangular</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">half_N</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">clusters</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">v</span><span class="p">:</span>
            <span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">nets</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>

        <span class="n">degrees</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">degree</span><span class="p">())</span>
        <span class="n">max_degree</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">degrees</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="k">if</span> <span class="n">degrees</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="n">node_sizes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">100</span> <span class="o">+</span> <span class="mi">400</span> <span class="o">*</span> <span class="n">degrees</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">/</span> <span class="n">max_degree</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()]</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos_rectangular</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">node_size</span><span class="o">=</span><span class="n">node_sizes</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="s1">&#39;skyblue&#39;</span><span class="p">,</span> <span class="n">font_size</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">font_weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">edge_color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mf">1.5</span><span class="p">)</span>
        <span class="n">num_networks</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Cluster </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="n">num_networks</span><span class="si">}</span><span class="s1"> networks, modes&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">network_num</span><span class="si">}</span><span class="s1"> Sythetic Networks, Inverse Compression Ratio: </span><span class="si">{</span><span class="n">L</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">(</span><span class="n">rect</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.03</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.95</span><span class="p">])</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p><strong>Step 7: Visualize the clustered networks</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">visualize_clusters</span><span class="p">(</span><span class="n">nets</span><span class="p">,</span> <span class="n">clusters</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">node_num</span><span class="p">,</span> <span class="n">network_num</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="example-output">
<h3>Example Output<a class="headerlink" href="#example-output" title="Link to this heading"></a></h3>
<figure class="align-default" id="id9">
<img alt="Example output showing the synthetic networks structure." src="../_images/synthetic_networks_population_example.png" />
<figcaption>
<p><span class="caption-text">Part of 2,000 Synthetic Networks with Cluster Labels. Each network is plotted with nodes colored light blue and labeled. The networks are arranged in a rectangular layout, with the title indicating the network number and its mode.</span><a class="headerlink" href="#id9" title="Link to this image"></a></p>
</figcaption>
</figure>
<figure class="align-default" id="id10">
<img alt="Example output showing the MDL population clustering results for synthetic networks." src="../_images/MDL_population_clusters_example.png" />
<figcaption>
<p><span class="caption-text">MDL Population Clustering Results for Synthetic Networks. Each cluster is represented by a subplot, with nodes colored light blue. The title of each subplot includes the cluster number and the number of networks in that cluster. The overall title indicates the total number of synthetic networks and the inverse compression ratio (L).</span><a class="headerlink" href="#id10" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
</section>
<section id="paper-source">
<h2>Paper source<a class="headerlink" href="#paper-source" title="Link to this heading"></a></h2>
<p>If you use this algorithm in your work, please cite:</p>
<p>A. Kirkley*, A. Rojas, M. Rosvall, and J-G. Young, Compressing network populations with modal networks reveals structural diversity. Communications Physics 6, 148 (2023).
Paper: <a class="reference external" href="https://arxiv.org/abs/2209.13827">https://arxiv.org/abs/2209.13827</a></p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="hypergraph_binning.html" class="btn btn-neutral float-left" title="Binning Temporal Hypergraphs" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="MDL_regionalization.html" class="btn btn-neutral float-right" title="Regionalization with Distributional Data" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Baiyue.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>